---
title: "Overview of the coded qualitative data"
output: 
  html_notebook: 
    number_sections: yes
    toc: yes
---
```{r, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
require(gridExtra)
require(tidyverse)
load("../data/codings.rda")
```

These notes describe the codings attributed to the qualitative data by raters. This description step will be followed by constructing a typology of instances of unauthorized access.

# Data
Analysis is based on the `codings` dataset, in which each row represents a code attributed to a story. It looks like this:

```{r}
str(codings, vec.len = 1, ncharmax = 80)
```
Where:

- `fid` is the story identifier
- `codename` is a code attributed by a rater, following a \<category\>-\<code\>-\<subcode\> convention.
- `category`, `code`, `subcode` unfold the coding convention
- `char_fid`is the total number of characters in the story
- `char_start` and `char_end` are characters delimiting the excerpt for which the code was attributed
- `description` is the description of codes or subcodes, formulated as an answer to a rating question
- `category.desc` is the description of the category, formulated as a rating question

The dataset was created by the `retrieve_data.R` script, which retrieves it from the RQDA database, merging fields in several tables. No previous transformations were performed.

This analysis will take top-down view, looking first at code categories, and progressively going deeper until reaching exemplary quotes. 

# Categories
## Descriptions

The category descriptions are as follows:
```{r}
codings %>%
  select(Category = category, Desription = category.desc) %>%
  distinct() %>% 
  knitr::kable()
```

## Factor and list categories
For most code categories, only one code was selected per per story (as evidenced by *[Choose one]* in the code description). However, for code categories `process` and `aftermath`, raters were free to not choose any code, or to choose many (*[Choose all that apply]*). 

### Factor categories
Categories for which raters were only able to select one code can map directly to categorical variables, or factors. Each code (or code-subcode if available) represents a level of that factor.

For instance, the category `lock` can be converted into factor, with the following levels:
```{r}
codings %>% 
  filter(category == "lock") %>%
  transmute(levels = codename, description) %>%
  distinct() %>%
  arrange(levels) %>%
  knitr::kable()
```

Some levels correspond to codes (following the category-code convention), and some correspond to subcodes (category-code-subcode). Because the codebook was designed to not allow selection of codes when subcodes were available, there is no overlap.

### List categories
Categories `process` and `aftermath` do not enjoy the same property of being easily transformed into a factor. They are, instead, list variables. For each story, each category maps to a list of codes or code-subcodes which may have been chosen by the rater. The list can be empty or have as many elements as there are options.

For instance, in the process category, stories were often rated with more than one code. Story 2, for instance, has 5 process codes.

```{r include=FALSE}
codings %>%
  filter(category == "process") %>%
  select(story = fid, codename) %>%
  group_by(story) %>%
  summarise(n_process_codes = n()) %>%
  filter(n_process_codes > 1) 
  
```

```{r}
codings %>% 
  filter(category == "process", fid == 2) %>%
  select(fid, category, code, subcode) %>%
  knitr::kable()
  
```
Because the codes represent processes that occured in an observational unit, it makes sense to think of them as list.

### Spreading the data

> TODO: Wide representation not needed here. Move to structure notebook.

Using this distintion of factor and list codes, we can now prepare a tidy dataset, `codings_wide`, in which each row represents an observation (a story), and each column represents a category. Depending on the type of category, a cell will either contain a level of a factor, or a list of codes/subcodes (which may be empty), represented as a vector.

```{r}
codings_wide = 
  codings %>% 
  select(fid, category, codename) %>%
  group_by(fid, category) %>%
  # convert all codes per fid/category into lists
  summarise(codename_list = list(codename)) %>%
  # make a column per category
  spread(category, codename_list) %>%
  # clean-up factor categories
  mutate_at(vars(-aftermath, -process), unlist) %>%
  # substitute NULLs in list categories for empty lists
  # with functional magic
  mutate(aftermath = map(aftermath, ~ . %||% character(0))) %>%
  mutate(process = map(process, ~ . %||% character(0))) %>%
  as_data_frame()
```

The first few rows of the widen dataset look like this:

```{r}
knitr::kable(head(codings_wide))
```

## Temporal structure
Since stories were collected through a narrative device, it is expectable that code categories follow a temporal pattern. 

The dataset contains an indication of the first character associated with a coding, as `chart_start`, and also the total story length, as `char_fid`. We can calculate a relative location in the text (from 0 to 1) where codes were assigned. We can then order categories by the mean relative location where codings started.

```{r}
categories_ordered = 
  codings %>% 
    mutate(
      relative_start = char_start / char_fid
      ) %>%
    group_by(category) %>%
    summarise(
      mean_relative_start = mean(relative_start)
      ) %>%
    arrange(mean_relative_start)
categories_ordered %>%
  knitr::kable()
```
The ordered categories are stored as `categories_ordered` dataset, to recover the ordering in subsequent visualizations.  This ordering is useful, for instance, for ordering the columns in the `codings_wide` dataset: 
```{r}
codings_wide = 
  codings_wide %>%
  select(fid, categories_ordered$category)
str(codings_wide, max.level = 1, vec.len = 1)
```

Instead of looking just at the mean, we can also see the distribution of relative start characters across categories. One way is with a violin plot:

```{r}
codings %>% 
  mutate(
    relative_start = char_start / char_fid,
    category = factor(category, levels = categories_ordered$category)
    ) %>%
  ggplot +
  aes(
    x = category, 
    y = relative_start
    ) + 
  geom_violin(scale = "width", trim = F, draw_quantiles = c(0.5)) +
  geom_point(alpha = 1/5)
```
Alternative, with the point range geom and coordinates flipped:

```{r}
codings %>% 
  mutate(
    relative_start = char_start / char_fid,
    category = factor(category, levels = rev(categories_ordered$category))
    ) %>%
  ggplot +
  aes(
    x = category, 
    y = relative_start
    ) + 
  stat_summary(
    fun.y = mean,
    fun.ymax = max,
    fun.ymin = min,
    geom = "pointrange"
  ) +
  geom_point(alpha = 1/10) + 
  coord_flip()

```


*Observations:*

Centering stories around the instance or pattern of unauthorized access, the categories can be seen as reflecting three moments in time: *before*, *during*, and *after*.

1. Before: code categories `relationshiptype`, `opportunity`, and `motivation`.
2. During: code categories `lock`, and `process`.
3. After: code categories `knowledge`, `aftermath`, and `status`.

A more succint visualization of this structural property could be made, but it seems unnecessary for now. (I previously tried `ggraph`, with a circular representation, and was not happy with the results.) The structure does reflect our observations of how the stories usually progressed, such as the following fictitious example:

> Ash and Val were friends (`relationshiptype`). Ash went to the bathroom and left the phone behind (`opportunity`). Val wanted to play a prank (`motivation`). The phone did not have a lock (`lock`), so Val got in and took stupid pictures (`process`). Ash found out a few days later (`knowledge`), was very mad (`aftermath`), and never spoke to Val again (`status`). 

To some extent, this structure might have been super-imposed in the story editing process. Coded raw stories can be checked for comparison.

# Code & subcode frequency
> TODO: Code frequecies, Subcode frequencies, relationships between codes in different categories, between codes in list categories (co-occurence)

The distribution of codes and subcodes is likely too rich to visualize in a single visualization. For instance, a barplot, even without the labels, is not helpful:
```{r}
codings %>%
  ggplot() +
  geom_bar(
    mapping = aes(
      x = category,
      fill = codename
    ),
    show.legend = F,
    alpha = 0,
    color = "black"
  ) +
  coord_flip()

```
Raters were not able to distinguish between codes or subcodes, but consolidating subcodes into codes may be informative. We'll next look at the distribution of codes and subcodes from both perpectives. For each category, we'll first represent the distribution of codings as raters saw them, and then consolidated into codes.

> TODO: revisit single plot with subcodes consolidated

*Observations:*

Even if the barchart with all categories is not very informative, some observations can be drawn. As expected, all categories, except for `process` and `aftermath`, have exactly has many observations as there are observational units. Category `process` has a higher number, because it was common that more than one process was involved in an intrusion story. Category `aftermath` has fewer observations, because many stories did not express emotional consequences to the level required by the coding criteria.

```{r}
# barplots will be created with the same functions (below) for consistency.
barplot_category = function(data_subset) {
    grid.arrange(
      get_barplot_category(data_subset),
      get_barplot_category(data_subset, consolidate = T),
      ncol = 2
    )
}

get_barplot_category = function(data_subset, consolidate = FALSE) { 
  if(consolidate) {
    data = 
      data_subset %>%
      mutate(variable = code)
  } else {
    data = 
      data_subset %>%
      mutate(variable = paste(code, subcode, sep = "-"))
  }
  
  plot = 
    data %>%
    ggplot() + 
    geom_bar(
      aes(
        x = fct_infreq(variable),
        fill = code
      ),
      show.legend = F
    ) +
    coord_flip() +
    xlab(NULL)
  
  plot =
    plot +
    ylab(
      ifelse(
        consolidate, 
        "Frequency (consolidated to codes)",
        "Frequency (as rated)"
      )
     )
  
  plot
}
```

## Category `relationshiptype`
The following types of relationship were coded:
```{r}
codings %>%
  filter(category == "relationshiptype") %>%
  group_by(codename) %>%
  summarise(description = unique(description)) %>%
  arrange(codename) %>%
  knitr::kable()
```


Distributed has follows:
```{r}
barplot_category(
  codings %>% filter(category == "relationshiptype")
  )
```
*Observations:*

- In most stories, the relationship between subjects was coded as `intimate`. 

- Stories of intrusions were passive subjects were coded as `friends` were also common.

- Non-intimate types of relationships are distinguished by subcodes, while `intimate`has not subcodes. The code could have subcodes indicating wether it is a current, former, or aspirational type of relationship, has the code description suggests. Issue is worthy of revisitation.

- It is conceivable that the relationship being intimate or non-intimate is a preponderant factor on how stories of intrusions progress. This hypothesis is also worth revisitation.

## Category `opportunity`
The following types of intrusion opportunities were coded:
```{r}
codings %>%
  filter(category == "opportunity") %>%
  group_by(codename) %>%
  summarise(description = unique(description)) %>%
  arrange(codename) %>%
  knitr::kable()
```


Distributed has follows:
```{r}
barplot_category(
  codings %>% filter(category == "opportunity")
  )
```
*Observations:*

* Raters understood intrusions happening, in the vast majority of cases, when devices were left unattended by the passive subject.

* Raters found several instantiations where devices were left temporarily unattended. Most commonly, they found stories to indicate devices being unattended while their owners went to the bathroom (code `unattended-bathroom`). Raters also found stories where devices were left unnatended in locations often deemed "trusted", such as the home or office, while passive subject went somewhere else, for instance to run errands, or to a meeting (codes `unattended-outside`, and `unattended-meeting`); and stories where passive subjects were asleep (`unattended-asleep`). These stories of intrusions thus substantiate the questioning of common assumptions of trustworthyness associated with locations.

* Situations where the opportunity for access was created by deceiving the passive subject (code `opportunity-deception`), or through access to a secondary device (code `opportunity-secondarydevice`) were much less common. Because those may be extreme cases, it is worth revisiting the association of these codes with, at least, motivation and process codes.

* The commonality of the "bathroom scenario" seem to suggest that intrusions can occur in very little time. This aspect might be of importance for system design. For instance, intrusion detection algorithms which require an substantial period of behavior acquisition prior to classification may be innefective in practice.

* It can also be speculated that the "bathroom scenario" provides a set of relatively safe, or otherwise favorable, conditions for active subjects. Such conditions may include a *predictable* length of time alone with the device, *forewarning* that the passive subject may return (e.g. aural notice of flushing, shower shuting off, or doors opening), *social etiquette* in favor of leaving the device unnattended (e.g. so as not to signal distrust), and passive subject's *trust* they are in a safe environment.












> TODO: explore addind the code description as either axes or labels.
