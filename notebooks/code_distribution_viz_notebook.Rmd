---
title: "Visualizing codings with diagrams"
output:
  html_notebook: default
  pdf_document: default
---
```{r "setup", include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
require(tidyverse)
```

These are notes on visualizing the codings with diagrams. The immediate goal is to describe the data. This will be followed by constructing a typology of instances of unauthorized access.

Analysis are based on the `codings` dataset, which looks like this:

```{r}
load("../data/codings.rda")
str(codings, vec.len = 1, ncharmax = 80)
```
Where:

- `fid` is the story identifier
- `codename` is a code attributed by a coder, following a category-code-subcode convention.
- `char_fid`is the total number of characters in the story
- `char_start` and `char_end` are characters delimiting the excerpt for which the code was attributed
- `category`, `code`, `subcode` unfold the coding convention
- `category.desc` is the description of the category, formulated as a question
- `description` is the description of codes or subcodes, formulated as an answer

# Objectives
This analysis will take top-down view, looking first at code categories, and progressively going deeper until reaching exemplary quotes. 

The objectives are as follows:

1. Understand the categories of codes (i.e., dimensions) which were found.
   i) Category descriptions.
   ii) Factor categories and list categories.
   iii) Temporal structure.
2. Understand the codes and subcodes which were found.
   i) Code frequecies
   ii) Subcode frequencies
3. Understand relationships
    i) Between codes in different categories
    ii) Between codes in list categories (co-occurence)

# Categories
## Descriptions

The category descriptions are as follows:
```{r}
codings %>%
  select(Category = category, Desription = category.desc) %>%
  distinct() %>% 
  knitr::kable()
```

## Factor and list categories
For most code categories, only one code was selected per per story (as evidenced by *[Choose one]* in the code description). However, for code categories `process` and `aftermath`, raters were free to not choose any code, or to choose many (*[Choose all that apply]*). 

### Factor categories
Categories for which rater were only able to select one code translate simply to categorical variables, or factors. Each code, or code-subcode combinations represents a level of that factor.

For instance, the category `lock` can be converted into factor, with the following levels:
```{r}
codings %>% 
  filter(category == "lock") %>%
  transmute(levels = codename, description) %>%
  distinct() %>%
  arrange(levels) %>%
  knitr::kable()
```

Some levels correspond to codes (following the category-code convention), and some correspond to subcodes (category-code-subcode). Because the codebook was designed to not allow selection of codes when subcodes were available, there is no overlap.

### List categories
Categories `process` and `aftermath` do not enjoy the same property of being easily transformed into a factor. They are, instead, list variables. For each observational unit, each category contains a list of codes or code-subcodes. The list can be empty or have as many elements as there are options.

For instance, in the process category, stories were often rated with more than one code:

```{r}
codings %>%
  filter(category == "process") %>%
  select(story = fid, codename) %>%
  group_by(story) %>%
  summarise(n_process_codes = n()) %>%
  filter(n_process_codes > 1)
```
Story 2, for instance, has 5 process codes:

```{r}
codings %>% 
  filter(category == "process", fid == 2) %>%
  select(fid, codename)
  
```
Because the codes represent processes that occured in an observational unit, it makes sense to think of them as list.

### Spreading the data
Using this distintion of factor and list codes, we can now prepare a tidy dataset, `codings_wide`, in which each row represents an observation (a story), and each column represents a category. Depending on the type of category, a cell will either contain a level of a factor, or a vector of codes/subcodes (which may be empty).

```{r}
codings_wide = 
  codings %>% 
  select(fid, category, codename) %>%
  group_by(fid, category) %>%
  # convert all codes per fid/category into lists
  summarise(codename_list = list(codename)) %>%
  # make a column per category
  spread(category, codename_list) %>%
  # clean-up factor categories
  mutate_at(vars(-aftermath, -process), unlist) %>%
  # substitute NULLs in list categories for empty lists
  # with functional magic
  mutate(aftermath = map(aftermath, ~ . %||% character(0))) %>%
  mutate(process = map(process, ~ . %||% character(0))) %>%
  as_data_frame()
```

The first few rows of the widen dataset look like this:

```{r}
knitr::kable(head(codings_wide))
```

## Temporal structure
Since stories were collected through a narrative device, it is expectable that code categories follow a temporal pattern. 

The dataset contains an indication of the first character associated with a coding, as `chart_start`, and also the total story length, as `char_fid`. We can calculate a relative location in the text (from 0 to 1) where codes were assigned, on average, and calculate the average per category. The ordered categories are stored as `categories_ordered` to recover the ordering in subsequent visualizations. 

```{r}
categories_ordered = 
  codings %>% 
    mutate(
      relative_start = char_start / char_fid
      ) %>%
    group_by(category) %>%
    summarise(
      mean_relative_start = mean(relative_start)
      ) %>%
    arrange(mean_relative_start)
categories_ordered
```

Instead of looking just at the mean, we can also see the distribution of relative start characters across categories with a violing plot. 

```{r}
codings %>% 
  mutate(
    relative_start = char_start / char_fid,
    category = factor(category, levels = categories_ordered$category)
    ) %>%
  ggplot +
  aes(
    x = category, 
    y = relative_start
    ) + 
  geom_violin(scale = "width", trim = F, draw_quantiles = c(0.5)) +
  geom_point()
```

Centering stories around the instance or pattern of unauthorized access, the categories can be seen as reflecting three moements in time: *before*, *during*, and *after*.

1. Before: code categories `relationshiptype`, `opportunity`, and `motivation`.
2. During: code categories `lock`, and `process`.
3. After: code categories `knowledge`, `aftermath`, and `status`.

> TODO: continue from here

```{r}
require(ggraph)

categories =
  data_frame(
    names = c(
      
      "opportunity",
      "lock",
      "process",
      "knowledge",
      "aftermath",
      "status",
      "relationshiptype",
      "motivation"
    )
  )

relations = tribble(
  ~from, ~to,
  "relationshiptype", "motivation",
  "motivation", "opportunity",
  "opportunity", "lock",
  "lock", "process",
  "process", "knowledge",
  "knowledge","aftermath",
  "aftermath","status"
) %>% 
  as_data_frame()

g = graph_from_data_frame(relations, directed = T, vertices = categories)

ggraph(g, layout = "circle") +
  geom_edge_link(arrow = arrow(length = unit(2, 'mm')), 
                 end_cap = circle(10, 'mm')) + 
  geom_node_label(aes(label = name),size = 3) +
  theme_graph()

```

> TODO: not satisfied with this. try other timeline visualizations.

# Codes

For this analysis, the focus will be on codes, *not* subcodes. To analyze at the code level, where only category and code are needed, only one instance of code per story is needed.

```{r}
codings.wo.subcodes =
  codings %>% 
  select(fid, category, code) %>%
  distinct()
str(codings.wo.subcodes, vec.len = 1, ncharmax = 80)
```

## Dealing with open dimensions categories
To be able to proceed with exploring visualizations, an additional dataset is created limited to the categorical dimensions. To easily conform with frequency analysis, categories are spread to collumns.

```{r echo=TRUE}
data.wide = 
  codings.wo.subcodes %>% 
  filter(category != "process" & 
           category != "aftermath") %>%
  spread(category, code) %>%
  # order by timeline
  select(fid, relationshiptype, motivation, opportunity, lock, knowledge, status)
str(data.wide, vec.len = 2)
```

Another common data representation used in visualizations is as a frequency table, where each line contains the frequency of a given combinations of codes.

```{r}
data.wide.freq =
  data.wide %>%
  select(-fid) %>%
  group_by_all() %>%
  summarise(freq = n()) %>%
  ungroup() %>%
  arrange(desc(freq))
str(data.wide.freq, vec.len = 3)
```

### Transformation

> TODO: revise when additional data comes in

Another approach that could be considered would be to transform the data in multi-code categories, so that they comply with the 1 observation per story format.

For both multi-code categories, cases where raters did not select any code can be trivially transformed in a "unspecified"-type level.

The problematic cases are those for which there was more than one coding. 

For aftermath, these are the cases with multiple codings:

```{r}
codings.wo.subcodes %>%
  select(fid, category, code) %>%
  filter(category == "aftermath") %>%
  arrange(code) %>%
  group_by(fid) %>%
  nest(code) %>%
  mutate(n = purrr::map_int(data, nrow),
         codes = purrr::map(data, unlist),
         codelist = purrr::map_chr(codes, paste, collapse = ", ")) %>%
  filter(n > 1) %>%
  select(fid, codelist) %>%
  arrange(codelist)
```
There appear to be the following patterns:

- Active subject has mixed feelings
- Both subjects have negative feelings

There is one instance which does not conform to this patter, which could be labeled as "others".

For process, these are the cases with multiple codings:

```{r}
codings.wo.subcodes %>%
  select(fid, category, code) %>%
  filter(category == "process") %>%
  arrange(code) %>%
  group_by(fid) %>%
  nest(code) %>%
  mutate(n = purrr::map_int(data, nrow),
         codes = purrr::map(data, unlist),
         codelist = purrr::map_chr(codes, paste, collapse = ", ")) %>%
  filter(n > 1) %>%
  select(fid, codelist) %>%
  arrange(codelist)
```
It appears that all combinations include snooping, plus one other kind of code.

However, it is not true that those other codes subsume "snooping". They sometimes occur on their own:

```{r}
snooping.fids =
  codings.wo.subcodes %>% 
  filter(category == "process" & code == "snooping") %>%
  .$fid

codings.wo.subcodes %>%
  filter(category == "process" &
           ! fid %in% snooping.fids)

```

A rule for transformation could be always choosing the other code. In that case, any selection of on of the other codes should be described as *possibly* subsumming "snooping". One disadvantage to this approach would be to possibly distort an analysis of the relationshiip of "snooping" codes and other codes.


# Alluvial diagrams 
## With [alluvial](https://CRAN.R-project.org/package=alluvial)
First, an attempt at creating an alluvial using the "alluvial" package. This package uses standard plotting. 

```{r echo=TRUE}
library(alluvial)
```



Here is the default alluvial representation:

```{r echo=TRUE}
alluvial(
  alluvial.data[,1:6],
  freq = alluvial.data$freq
)
```

The graph conveys the correct code frequencies for each category, limited to the single-choice categories. However, the relationships between codes are difficult to make sense of.

Using this package, the input is a contigency table, and the alluvia can be followed from beggining to end, their thickness representing frequency. The graph would be easier to understand if alluvials only represented pairwise relationships between adjoining categories, i.e. pairwise "of which" relationships. 

Even with these constraints, there is some room to improve on the graph, by adding colors and tinkering with ordering. 

```{r}
# Create orderings
alluvial.data = 
  alluvial.data %>% 
  mutate(
    relationshiptype.order = 
      case_when(
        relationshiptype == "intimate" ~ 1,
        relationshiptype == "nonintimate" ~ 2,
        relationshiptype == "unspecified" ~ 3,
        TRUE ~ 0
        ),
    motivation.order = 
      case_when(
        motivation == "control" ~ 1,
        motivation == "exploit" ~ 2,
        motivation == "prank" ~ 3,
        motivation == "convenience" ~ 4,
        motivation == "accidental" ~ 5,
        motivation == "unspecified" ~ 6,
        TRUE ~ 0
        ),
    opportunity.order = 
      case_when(
        opportunity == "unattended" ~ 1,
        opportunity == "deception" ~ 2,
        opportunity == "secondarydevice" ~ 3,
        opportunity == "unspecified" ~ 4,
        TRUE ~0
      )
  ) 
alluvial(
  alluvial.data[,1:6],
  freq = alluvial.data$freq,
  border = alluvial.data$relationshiptype.order + 1,
  col = alluvial.data$relationshiptype.order + 1,
  ordering = list(
    alluvial.data$relationshiptype.order,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL
  ),
  gap.width = .1,
  cex = .7,
  blocks = T
  #alpha = 0.7,
)
```


Code for the previous graph is very hacky. The vertical ordering of levels is an experimental feature, and I found no way of properly ordering past the first category. 

Conclusion: objective 1, of representing code frequencies, is partially accomplished, by the stacked barplot format of the alluvial nodes. However, relationships of adjoining codes are difficult to discern. Additionally, there is very little flexibility for tinkering with the basic plot.

## With [ggalluvial](https://CRAN.R-project.org/package=ggalluvial)

> Ongoing

First attempt, using the same data.
```{r}
library(ggalluvial)
alluvial.data %>% 
  ggplot(aes(weight = freq, 
             axis1 = relationshiptype, 
             axis2 = motivation,
             axis3 = opportunity,
             axis4 = lock,
             axis5 = knowledge,
             axis6 = status)) +
  geom_alluvium(aes(fill = motivation), width = 1/12) +
  geom_stratum(width = 1/12, fill = "black", color = "grey") +
  geom_label(stat = "stratum", label.strata = TRUE) +
  scale_x_continuous(breaks = 1:6, labels = c(names(data))[1:6]) + #, labels = names(data)) +
  ggtitle("Story codings alluvial")

```


# Code relationships within moments


