---
title: "Overview of the coded qualitative data"
output: 
  html_notebook: 
    number_sections: yes
    toc: yes
---
```{r, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
require(gridExtra)
require(tidyverse)
load("../data/codings.rda")
```

These notes describe the codings attributed to the qualitative data by raters. This description step will be followed by constructing a typology of instances of unauthorized access.

# Data
Analysis is based on the `codings` dataset, in which each row represents a code attributed to a story. It looks like this:

```{r}
str(codings, vec.len = 1, ncharmax = 80)
```
Where:

- `fid` is the story identifier
- `codename` is a code attributed by a rater, following a \<category\>-\<code\>-\<subcode\> convention.
- `category`, `code`, `subcode` unfold the coding convention
- `char_fid`is the total number of characters in the story
- `char_start` and `char_end` are characters delimiting the excerpt for which the code was attributed
- `description` is the description of codes or subcodes, formulated as an answer to a rating question
- `category.desc` is the description of the category, formulated as a rating question

The dataset was created by the `retrieve_data.R` script, which retrieves it from the RQDA database, merging fields in several tables. No previous transformations were performed.

This analysis will take top-down view, looking first at code categories, and progressively going deeper until reaching exemplary quotes. 

# Categories
## Descriptions

The category descriptions are as follows:
```{r}
codings %>%
  select(Category = category, Desription = category.desc) %>%
  distinct() %>% 
  knitr::kable()
```

## Factor and list categories
For most code categories, only one code was selected per per story (as evidenced by *[Choose one]* in the code description). However, for code categories `process` and `aftermath`, raters were free to not choose any code, or to choose many (*[Choose all that apply]*). 

### Factor categories
Categories for which raters were only able to select one code can map directly to categorical variables, or factors. Each code (or code-subcode if available) represents a level of that factor.

For instance, the category `lock` can be converted into factor, with the following levels:
```{r}
codings %>% 
  filter(category == "lock") %>%
  transmute(levels = codename, description) %>%
  distinct() %>%
  arrange(levels) %>%
  knitr::kable()
```

Some levels correspond to codes (following the category-code convention), and some correspond to subcodes (category-code-subcode). Because the codebook was designed to not allow selection of codes when subcodes were available, there is no overlap.

### List categories
Categories `process` and `aftermath` do not enjoy the same property of being easily transformed into a factor. They are, instead, list variables. For each story, each category maps to a list of codes or code-subcodes which may have been chosen by the rater. The list can be empty or have as many elements as there are options.

For instance, in the process category, stories were often rated with more than one code. Story 2, for instance, has 5 process codes.

```{r include=FALSE}
codings %>%
  filter(category == "process") %>%
  select(story = fid, codename) %>%
  group_by(story) %>%
  summarise(n_process_codes = n()) %>%
  filter(n_process_codes > 1) 
  
```

```{r}
codings %>% 
  filter(category == "process", fid == 2) %>%
  select(fid, category, code, subcode) %>%
  knitr::kable()
  
```
Because the codes represent processes that occured in an observational unit, it makes sense to think of them as list.

### Spreading the data
Using this distintion of factor and list codes, we can now prepare a tidy dataset, `codings_wide`, in which each row represents an observation (a story), and each column represents a category. Depending on the type of category, a cell will either contain a level of a factor, or a list of codes/subcodes (which may be empty), represented as a vector.

```{r}
codings_wide = 
  codings %>% 
  select(fid, category, codename) %>%
  group_by(fid, category) %>%
  # convert all codes per fid/category into lists
  summarise(codename_list = list(codename)) %>%
  # make a column per category
  spread(category, codename_list) %>%
  # clean-up factor categories
  mutate_at(vars(-aftermath, -process), unlist) %>%
  # substitute NULLs in list categories for empty lists
  # with functional magic
  mutate(aftermath = map(aftermath, ~ . %||% character(0))) %>%
  mutate(process = map(process, ~ . %||% character(0))) %>%
  as_data_frame()
```

The first few rows of the widen dataset look like this:

```{r}
knitr::kable(head(codings_wide))
```

## Temporal structure
Since stories were collected through a narrative device, it is expectable that code categories follow a temporal pattern. 

The dataset contains an indication of the first character associated with a coding, as `chart_start`, and also the total story length, as `char_fid`. We can calculate a relative location in the text (from 0 to 1) where codes were assigned. We can then order categories by the mean relative location where codings started.

```{r}
categories_ordered = 
  codings %>% 
    mutate(
      relative_start = char_start / char_fid
      ) %>%
    group_by(category) %>%
    summarise(
      mean_relative_start = mean(relative_start)
      ) %>%
    arrange(mean_relative_start)
categories_ordered %>%
  knitr::kable()
```
The ordered categories are stored as `categories_ordered` dataset, to recover the ordering in subsequent visualizations.  This ordering is useful, for instance, for ordering the columns in the `codings_wide` dataset: 
```{r}
codings_wide = 
  codings_wide %>%
  select(fid, categories_ordered$category)
str(codings_wide, max.level = 1, vec.len = 1)
```

Instead of looking just at the mean, we can also see the distribution of relative start characters across categories. One way is with a violin plot:

```{r}
codings %>% 
  mutate(
    relative_start = char_start / char_fid,
    category = factor(category, levels = categories_ordered$category)
    ) %>%
  ggplot +
  aes(
    x = category, 
    y = relative_start
    ) + 
  geom_violin(scale = "width", trim = F, draw_quantiles = c(0.5)) +
  geom_point(alpha = 1/5)
```
Alternative, with the point range geom and coordinates flipped:

```{r}
codings %>% 
  mutate(
    relative_start = char_start / char_fid,
    category = factor(category, levels = rev(categories_ordered$category))
    ) %>%
  ggplot +
  aes(
    x = category, 
    y = relative_start
    ) + 
  stat_summary(
    fun.y = mean,
    fun.ymax = max,
    fun.ymin = min,
    geom = "pointrange"
  ) +
  geom_point(alpha = 1/10) + 
  coord_flip()

```


*Observations:*

Centering stories around the instance or pattern of unauthorized access, the categories can be seen as reflecting three moments in time: *before*, *during*, and *after*.

1. Before: code categories `relationshiptype`, `opportunity`, and `motivation`.
2. During: code categories `lock`, and `process`.
3. After: code categories `knowledge`, `aftermath`, and `status`.

A more succint visualization of this structural property could be made, but it seems unnecessary for now. (I previously tried `ggraph`, with a circular representation, and was not happy with the results.) The structure does reflect our observations of how the stories usually progressed, such as the following fictitious example:

> Ash and Val were friends (`relationshiptype`). Ash went to the bathroom and left the phone behind (`opportunity`). Val wanted to play a prank (`motivation`). The phone did not have a lock (`lock`), so Val got in and took stupid pictures (`process`). Ash found out a few days later (`knowledge`), was very mad (`aftermath`), and never spoke to Val again (`status`). 

To some extent, this structure might have been super-imposed in the story editing process. Coded raw stories can be checked for comparison.

# Codes & subcodes
> TODO: Code frequecies, Subcode frequencies, relationships between codes in different categories, between codes in list categories (co-occurence)

The distribution of codes and subcodes is likely too rich to visualize in a single visualization. For instance, a barplot, even without the labels, is not helpful:
```{r}
codings %>%
  ggplot() +
  geom_bar(
    mapping = aes(
      x = category,
      fill = codename
    ),
    show.legend = F,
    alpha = 0,
    color = "black"
  ) +
  coord_flip()

```
Raters were not able to distinguish between codes or subcodes, but consolidating subcodes into codes may be informative. We'll next look at the distribution of codes and subcodes from both perpectives. For each category, we'll first represent the distribution of codings as raters saw them, and then consolidated into codes.

> TODO: revisit single plot with subcodes consolidated

*Observations:*

Even if the barchart with all categories is not very informative, some observations can be drawn. As expected, all categories, except for `process` and `aftermath`, have exactly has many observations as there are observational units. Category `process` has a higher number, because it was common that more than one process was involved in an intrusion story. Category `aftermath` has fewer observations, because many stories did not express emotional consequences to the level required by the coding criteria.

```{r}
# barplots will be created with the same functions (below) for consistency.
barplot_category = function(data_subset) {
    grid.arrange(
      get_barplot_category(data_subset),
      get_barplot_category(data_subset, consolidate = T),
      ncol = 2
    )
}

get_barplot_category = function(data_subset, consolidate = FALSE) { 
  if(consolidate) {
    data = 
      data_subset %>%
      mutate(variable = code)
  } else {
    data = 
      data_subset %>%
      mutate(variable = paste(code, subcode, sep = "-"))
  }
  
  plot = 
    data %>%
    ggplot() + 
    geom_bar(
      aes(
        x = fct_infreq(variable),
        fill = code
      ),
      show.legend = F
    ) +
    coord_flip() +
    xlab(NULL)
  
  plot =
    plot +
    ylab(
      ifelse(
        consolidate, 
        "Frequency (consolidated to codes)",
        "Frequency (as rated)"
      )
     )
  
  plot
}
```

## Category `relationshiptype`
The following types of relationship were coded:
```{r}
codings %>%
  filter(category == "relationshiptype") %>%
  group_by(codename) %>%
  summarise(description = unique(description)) %>%
  arrange(codename) %>%
  knitr::kable()
```


Distributed has follows:
```{r}
barplot_category(
  codings %>% filter(category == "relationshiptype")
  )
```
*Observations:*

- In most stories, the relationship between subjects was coded as `intimate`. 

- Stories of intrusions were passive subjects were coded as `friends` were also common.

- Non-intimate types of relationships are distinguished by subcodes, while `intimate`has not subcodes. The code could have subcodes indicating wether it is a current, former, or aspirational type of relationship, has the code description suggests. Issue is worthy of revisitation.








> TODO: remove / revise everything below

For this analysis, the focus will be on codes, *not* subcodes. To analyze at the code level, where only category and code are needed, only one instance of code per story is needed.

```{r}
codings.wo.subcodes =
  codings %>% 
  select(fid, category, code) %>%
  distinct()
str(codings.wo.subcodes, vec.len = 1, ncharmax = 80)
```

## Dealing with open dimensions categories
To be able to proceed with exploring visualizations, an additional dataset is created limited to the categorical dimensions. To easily conform with frequency analysis, categories are spread to collumns.

```{r echo=TRUE}
data.wide = 
  codings.wo.subcodes %>% 
  filter(category != "process" & 
           category != "aftermath") %>%
  spread(category, code) %>%
  # order by timeline
  select(fid, relationshiptype, motivation, opportunity, lock, knowledge, status)
str(data.wide, vec.len = 2)
```

Another common data representation used in visualizations is as a frequency table, where each line contains the frequency of a given combinations of codes.

```{r}
data.wide.freq =
  data.wide %>%
  select(-fid) %>%
  group_by_all() %>%
  summarise(freq = n()) %>%
  ungroup() %>%
  arrange(desc(freq))
str(data.wide.freq, vec.len = 3)
```

### Transformation

> TODO: revise when additional data comes in

Another approach that could be considered would be to transform the data in multi-code categories, so that they comply with the 1 observation per story format.

For both multi-code categories, cases where raters did not select any code can be trivially transformed in a "unspecified"-type level.

The problematic cases are those for which there was more than one coding. 

For aftermath, these are the cases with multiple codings:

```{r}
codings.wo.subcodes %>%
  select(fid, category, code) %>%
  filter(category == "aftermath") %>%
  arrange(code) %>%
  group_by(fid) %>%
  nest(code) %>%
  mutate(n = purrr::map_int(data, nrow),
         codes = purrr::map(data, unlist),
         codelist = purrr::map_chr(codes, paste, collapse = ", ")) %>%
  filter(n > 1) %>%
  select(fid, codelist) %>%
  arrange(codelist)
```
There appear to be the following patterns:

- Active subject has mixed feelings
- Both subjects have negative feelings

There is one instance which does not conform to this patter, which could be labeled as "others".

For process, these are the cases with multiple codings:

```{r}
codings.wo.subcodes %>%
  select(fid, category, code) %>%
  filter(category == "process") %>%
  arrange(code) %>%
  group_by(fid) %>%
  nest(code) %>%
  mutate(n = purrr::map_int(data, nrow),
         codes = purrr::map(data, unlist),
         codelist = purrr::map_chr(codes, paste, collapse = ", ")) %>%
  filter(n > 1) %>%
  select(fid, codelist) %>%
  arrange(codelist)
```
It appears that all combinations include snooping, plus one other kind of code.

However, it is not true that those other codes subsume "snooping". They sometimes occur on their own:

```{r}
snooping.fids =
  codings.wo.subcodes %>% 
  filter(category == "process" & code == "snooping") %>%
  .$fid

codings.wo.subcodes %>%
  filter(category == "process" &
           ! fid %in% snooping.fids)

```

A rule for transformation could be always choosing the other code. In that case, any selection of on of the other codes should be described as *possibly* subsumming "snooping". One disadvantage to this approach would be to possibly distort an analysis of the relationshiip of "snooping" codes and other codes.


# Alluvial diagrams 
## With [alluvial](https://CRAN.R-project.org/package=alluvial)
First, an attempt at creating an alluvial using the "alluvial" package. This package uses standard plotting. 

```{r echo=TRUE}
library(alluvial)
```



Here is the default alluvial representation:

```{r echo=TRUE}
alluvial(
  alluvial.data[,1:6],
  freq = alluvial.data$freq
)
```

The graph conveys the correct code frequencies for each category, limited to the single-choice categories. However, the relationships between codes are difficult to make sense of.

Using this package, the input is a contigency table, and the alluvia can be followed from beggining to end, their thickness representing frequency. The graph would be easier to understand if alluvials only represented pairwise relationships between adjoining categories, i.e. pairwise "of which" relationships. 

Even with these constraints, there is some room to improve on the graph, by adding colors and tinkering with ordering. 

```{r}
# Create orderings
alluvial.data = 
  alluvial.data %>% 
  mutate(
    relationshiptype.order = 
      case_when(
        relationshiptype == "intimate" ~ 1,
        relationshiptype == "nonintimate" ~ 2,
        relationshiptype == "unspecified" ~ 3,
        TRUE ~ 0
        ),
    motivation.order = 
      case_when(
        motivation == "control" ~ 1,
        motivation == "exploit" ~ 2,
        motivation == "prank" ~ 3,
        motivation == "convenience" ~ 4,
        motivation == "accidental" ~ 5,
        motivation == "unspecified" ~ 6,
        TRUE ~ 0
        ),
    opportunity.order = 
      case_when(
        opportunity == "unattended" ~ 1,
        opportunity == "deception" ~ 2,
        opportunity == "secondarydevice" ~ 3,
        opportunity == "unspecified" ~ 4,
        TRUE ~0
      )
  ) 
alluvial(
  alluvial.data[,1:6],
  freq = alluvial.data$freq,
  border = alluvial.data$relationshiptype.order + 1,
  col = alluvial.data$relationshiptype.order + 1,
  ordering = list(
    alluvial.data$relationshiptype.order,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL
  ),
  gap.width = .1,
  cex = .7,
  blocks = T
  #alpha = 0.7,
)
```


Code for the previous graph is very hacky. The vertical ordering of levels is an experimental feature, and I found no way of properly ordering past the first category. 

Conclusion: objective 1, of representing code frequencies, is partially accomplished, by the stacked barplot format of the alluvial nodes. However, relationships of adjoining codes are difficult to discern. Additionally, there is very little flexibility for tinkering with the basic plot.

## With [ggalluvial](https://CRAN.R-project.org/package=ggalluvial)

> Ongoing

First attempt, using the same data.
```{r}
library(ggalluvial)
alluvial.data %>% 
  ggplot(aes(weight = freq, 
             axis1 = relationshiptype, 
             axis2 = motivation,
             axis3 = opportunity,
             axis4 = lock,
             axis5 = knowledge,
             axis6 = status)) +
  geom_alluvium(aes(fill = motivation), width = 1/12) +
  geom_stratum(width = 1/12, fill = "black", color = "grey") +
  geom_label(stat = "stratum", label.strata = TRUE) +
  scale_x_continuous(breaks = 1:6, labels = c(names(data))[1:6]) + #, labels = names(data)) +
  ggtitle("Story codings alluvial")

```


# Code relationships within moments


